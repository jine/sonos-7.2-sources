//-----------------------------------------------------------------------------
//  
// linux/drivers/video/epson/s1d13xxxfb.c -- frame buffer driver for Epson 
// S1D13xxxseries of LCD/CRT/TV controllers.
//
// Copyright(c) 2000, 2003 Epson Research and Development, Inc.  
// All rights reserved.
//
//---------------------------------------------------------------------------- 
//
// WARNING: This file uses a chip speciphic include file. The include file 
// contains all hardware information needed to generate proper timings, color
// depth, screen resolution etc. If the include file was generated by a Windows 
// based chip configuration utility, make sure the generated file was converted
// to Linux native text file format, i.e. process the file with dos2unix utility 
// or similar.
// 
// THIS DRIVER WILL NOT BUILD CORRECTLY IF THE INCLUDE FILE IS IN DOS 
// TEXT FILE FORMAT.                                                 
//
// This driver supports one of the following Epson CRT/TV/LCD controllers:
//
// S1D13504
// S1D13505
// S1D13506
// S1D13704
// S1D13705
// S1D13706
// S1D13806
// S1D13A03
// S1D13A04
// S1D13A05
//
// The intended platforms for this driver are embedded systems, where memory 
// resources are very limited, hence there are virtually no run-time checks
// present in the driver code. The objective is to keep the footprint as small
// as possible. For example, we do not keep a mirror image of palette. The con-
// sequence being that writing a palette entry and then reading it back may
// result in different value, as most of the supported chips don't support 
// full 8 bits per primary colors (red, green, blue). 
// This does not seem to affect the driver much.
//
// During the driver compilation, the following hash-defines are being used to 
// identify the target Epson controller:
//
// CONFIG_FBCON_EPSON_S1D13504 
// CONFIG_FBCON_EPSON_S1D13505 
// CONFIG_FBCON_EPSON_S1D13506 
// CONFIG_FBCON_EPSON_S1D13704 
// CONFIG_FBCON_EPSON_S1D13705 
// CONFIG_FBCON_EPSON_S1D13706 
// CONFIG_FBCON_EPSON_S1D13806
// CONFIG_FBCON_EPSON_S1D13A03
// CONFIG_FBCON_EPSON_S1D13A04
// CONFIG_FBCON_EPSON_S1D13A05
//
// Most of the chips were tested using Epson evaluation boards. The boards come
// basically in two flavors: ISA bus adapters or PCI adapters. To support the
// PCI adapters, make sure to specify PCI bridge adapter during configuration.
// This will generate the following hash-define:
//
// CONFIG_FBCON_EPSON_PCI
// 
// The driver will be build for one colordepth only. It must be one of the 
// following: 4Bpp,8Bpp or 16Bpp. This is selected during the configuration 
// phase and generates one of the hash-defines: 
//
// FBCON_HAS_MFB
// FBCON_HAS_CFB2
// FBCON_HAS_CFB4
// FBCON_HAS_CFB8
// FBCON_HAS_CFB16
//
// Additionally,there are some hash-defines specifying the display geometry
// and LUT register accesses. These are chip dependent and are located in 
// corresponding S1D13XXX header files. 
//
//-----------------------------------------------------------------------------

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/errno.h>
#include <linux/string.h>
#include <linux/mm.h>
#include <linux/tty.h>
#include <linux/slab.h>
#include <linux/delay.h>
#include <linux/fb.h>
#include <linux/init.h>

#include <linux/pci.h>
#include <video/fbcon.h> 
#include <video/fbcon-mfb.h>
#include <video/fbcon-cfb2.h>
#include <video/fbcon-cfb4.h>
#include <video/fbcon-cfb8.h>
#include <video/fbcon-cfb16.h>

#if defined(CONFIG_SH_SONOS_HH)
#include <linux/rincon_pm.h>
#include <asm/io.h>
#include <asm/uaccess.h>
#include <asm/machvec.h>
#include "mdp.h"

static void sleep(struct pmdevice *);
static void wake(struct pmdevice *);

struct pmdevice epson_pmdevice = {
	0,
	"epson_pm",
	sleep,
	wake,
	0
};
extern struct manufacturing_data_page sys_mdp;

#define BACKLIGHT_OFF_TS1 0x3E
#define BACKLIGHT_ON_TS1 0x37
#define BACKLIGHT_OFF_TS2 0x06
#define BACKLIGHT_ON_TS2 0x07
#define BACKLIGHT_ON_FULL_TS2 0x0E
#define SYS_IS_TS2 (sys_mdp.mdp_submodel==MDP_SUBMODEL_TS2)
#endif
 
//----------------------------------------------------------------------------- 
//
// Sanity checks
// 
//----------------------------------------------------------------------------- 

// Check if at least one supported colordepth was configured

#if !defined (FBCON_HAS_MFB) && !defined (FBCON_HAS_CFB2) && \
    !defined (FBCON_HAS_CFB4) && !defined (FBCON_HAS_CFB8) && \
    !defined (FBCON_HAS_CFB16)
    #error No colordepth specified
#endif

// Check at most one colordepth was configured

#if defined (FBCON_HAS_MFB)
    #if defined (FBCON_HAS_CFB2) || defined (FBCON_HAS_CFB4) || \
        defined (FBCON_HAS_CFB8) || defined (FBCON_HAS_CFB16)
        #error More than one colordepth specified 
    #endif
#endif

#if defined (FBCON_HAS_CFB2)
    #if defined (FBCON_HAS_MFB) || defined (FBCON_HAS_CFB4) || \
        defined (FBCON_HAS_CFB8) || defined (FBCON_HAS_CFB16)
        #error More than one colordepth specified 
    #endif
#endif

#if defined (FBCON_HAS_CFB4)
    #if defined (FBCON_HAS_MFB) || defined (FBCON_HAS_CFB2) || \
        defined (FBCON_HAS_CFB8) || defined (FBCON_HAS_CFB16)
        #error More than one colordepth specified 
    #endif
#endif

#if defined (FBCON_HAS_CFB8)
    #if defined (FBCON_HAS_MFB) || defined (FBCON_HAS_CFB2) || \
        defined (FBCON_HAS_CFB4) || defined (FBCON_HAS_CFB16)
        #error More than one colordepth specified 
    #endif
#endif

#if defined (FBCON_HAS_CFB16)
    #if defined (FBCON_HAS_MFB) || defined (FBCON_HAS_CFB2) || \
        defined (FBCON_HAS_CFB4) || defined (FBCON_HAS_CFB8)
        #error More than one colordepth specified 
    #endif
#endif

// S1D13504 supports only 1bpp, 2bpp, 4Bpp, 16Bpp
#ifdef CONFIG_FBCON_EPSON_S1D13504 
    #if defined (FBCON_HAS_CFB8) || !defined(FBCON_HAS_CFB16)
        #error Invalid configuration!
    #endif
#include "s1d13504.h"
#endif

// S1D13505 supports 1bpp, 2bpp, 4bpp, 8Bpp, 16Bpp
#ifdef CONFIG_FBCON_EPSON_S1D13505 
#include "s1d13505.h"
#endif

// S1D13506 supports 4Bpp, 8Bpp, 16Bpp
#ifdef CONFIG_FBCON_EPSON_S1D13506 
    #if defined (FBCON_HAS_MFB) || defined (FBCON_HAS_CFB2)
        #error Invalid configuration!
    #endif
#include "s1d13506.h"
#endif

// S1D13704 supports 1bpp, 2bpp, 4bpp
#ifdef CONFIG_FBCON_EPSON_S1D13704 
    #if defined (FBCON_HAS_CFB16) || defined (FBCON_HAS_CFB8)
        #error Invalid configuration!
    #endif
#include "s1d13704.h"
#endif

// S1D13705 supports 1bpp, 2bpp, 4Bpp, 8Bpp
#ifdef CONFIG_FBCON_EPSON_S1D13705 
#if defined (FBCON_HAS_CFB16)
        #error Invalid configuration!
    #endif
#include "s1d13705.h"
#endif

// S1D13706 supports 1bpp, 2bpp, 4Bpp, 8Bpp, 16Bpp
#ifdef CONFIG_FBCON_EPSON_S1D13706 
#include "s1d13706.h"
#endif

// S1D13806 supports 4Bpp,8Bpp,16Bpp
#ifdef CONFIG_FBCON_EPSON_S1D13806 
    #if defined (FBCON_HAS_MFB) ||| defined (FBCON_HAS_CFB2)
        #error Invalid configuration!
    #endif
#include "s1d13806.h"
#endif

// S1D13A03 supports 1bpp, 2bpp, 4Bpp, 8Bpp, 16Bpp
#ifdef CONFIG_FBCON_EPSON_S1D13A03 
#include "s1d13a0x.h"
S1D_INSTANTIATE_REGISTERS(static,aS1DRegs);
#endif


// S1D13A04 supports 1bpp, 2bpp, 4Bpp, 8Bpp, 16Bpp
#ifdef CONFIG_FBCON_EPSON_S1D13A04 
#include "s1d13a0x.h"
S1D_INSTANTIATE_REGISTERS(static,aS1DRegs);
#endif

// S1D13A05 supports 1bpp, 2bpp, 4Bpp, 8Bpp, 16Bpp
#ifdef CONFIG_FBCON_EPSON_S1D13A05 
#include "s1d13a05.h"
S1D_INSTANTIATE_REGISTERS(static,aS1DRegs);
#endif

// Now that the include file has been successfully read in, make sure 
// it's for the right colordepth

#if (defined (FBCON_HAS_MFB) && (S1D_DISPLAY_BPP != 1)) || \
    (!defined(FBCON_HAS_MFB) && (S1D_DISPLAY_BPP == 1))
    #error Include file colordepth mismatch!
#endif

#if (defined (FBCON_HAS_CFB2) && (S1D_DISPLAY_BPP != 2)) || \
    (!defined(FBCON_HAS_CFB2) && (S1D_DISPLAY_BPP == 2))
    #error Include file colordepth mismatch!
#endif

#if (defined (FBCON_HAS_CFB4) && (S1D_DISPLAY_BPP != 4)) || \
    (!defined(FBCON_HAS_CFB4) && (S1D_DISPLAY_BPP == 4))
    #error Include file colordepth mismatch!
#endif

#if (defined (FBCON_HAS_CFB8) && (S1D_DISPLAY_BPP != 8)) || \
    (!defined(FBCON_HAS_CFB8) && (S1D_DISPLAY_BPP == 8))
    #error Include file colordepth mismatch!
#endif

#if (defined (FBCON_HAS_CFB16) && (S1D_DISPLAY_BPP != 16)) || \
    (!defined(FBCON_HAS_CFB16) && (S1D_DISPLAY_BPP == 16))
    #error Include file colordepth mismatch!
#endif

//----------------------------------------------------------------------------- 
//
// Local Definitions
// 
//--------------------------------------------------------------------------- 

typedef struct   
    {
    struct fb_info_gen gen;
    unsigned char *VmemAddr; 
    volatile unsigned char *RegAddr; 
#ifdef CONFIG_FBCON_EPSON_PCI 
    u32 PhysAddr;
#endif
#ifdef FBCON_HAS_CFB16
    u16 cfb16[16];
#endif
    }FB_INFO_S1D13xxx; 

//-----------------------------------------------------------------------------
//
// Function Prototypes 
// 
//-----------------------------------------------------------------------------

int __init s1d13xxxfb_setup(char *options, int *ints) ;
int __init s1d13xxxfb_init(char*) ;

static void s1d13xxx_detect(void); 
static int  s1d13xxx_encode_fix(struct fb_fix_screeninfo *fix, const void *par, 
                struct fb_info_gen *info); 
static int  s1d13xxx_decode_var(const struct fb_var_screeninfo *var, void *par, 
                struct fb_info_gen *info); 
static int  s1d13xxx_encode_var(struct fb_var_screeninfo *var, const void *par,
                struct fb_info_gen *info); 
static void s1d13xxx_get_par(void *par, struct fb_info_gen *info); 
static void s1d13xxx_set_par(const void *par, struct fb_info_gen *info); 
static int  s1d13xxx_getcolreg(unsigned regno, unsigned *red, unsigned *green, 
                unsigned *blue, unsigned *transp, struct fb_info *info); 
static int  s1d13xxx_setcolreg(unsigned regno, unsigned red, unsigned green,
                unsigned blue, unsigned transp, struct fb_info *info); 
static int  s1d13xxx_pan_display(const struct fb_var_screeninfo *var, 
                struct fb_info_gen *info); 
static int  s1d13xxx_blank(int blank_mode, struct fb_info_gen *info); 
static void s1d13xxx_set_disp(const void *par, struct display *disp,
                struct fb_info_gen *info);

#if defined(CONFIG_SH_SONOS_HH)
static int s1d13xxxfb_ioctl(struct inode *inode, struct file *file,
                       u_int cmd, u_long arg, int con,
               struct fb_info *info);
#endif

//----------------------------------------------------------------------------- 
//
// Local globals
// 
//----------------------------------------------------------------------------- 
#if (defined (FBCON_HAS_MFB) || defined (FBCON_HAS_CFB2))

static int s1d13xxx_set_cmap(struct fb_cmap *cmap, int kspc, int con,struct fb_info *info);

static struct fb_ops s1d13xxxfb_ops = 
    {
    owner:       THIS_MODULE,
    fb_get_fix:  fbgen_get_fix,
    fb_get_var:  fbgen_get_var,
    fb_set_var:  fbgen_set_var,
    fb_get_cmap: fbgen_get_cmap,
    fb_set_cmap: s1d13xxx_set_cmap,
#if defined(CONFIG_SH_SONOS_HH)
	fb_ioctl:	 s1d13xxxfb_ioctl,
#endif
    };

static int s1d13xxx_set_cmap(struct fb_cmap *cmap, int kspc, int con,
		   struct fb_info *info)
    {
    return 0;
    }

#else
static struct fb_ops s1d13xxxfb_ops = 
    {
    owner:       THIS_MODULE,
    fb_get_fix:  fbgen_get_fix,
    fb_get_var:  fbgen_get_var,
    fb_set_var:  fbgen_set_var,
    fb_get_cmap: fbgen_get_cmap,
    fb_set_cmap: fbgen_set_cmap,
#if defined(CONFIG_SH_SONOS_HH)
	fb_ioctl:	 s1d13xxxfb_ioctl,
#endif
    };
#endif

/*
 *  In most cases the `generic' routines (fbgen_*) should be satisfactory.
 *  However, you're free to fill in your own replacements.
 */
static struct fbgen_hwswitch s1d13xxx_hwswitch =  
    { 
    s1d13xxx_detect, 
    s1d13xxx_encode_fix, 
    s1d13xxx_decode_var, 
    s1d13xxx_encode_var, 
    s1d13xxx_get_par, 
    s1d13xxx_set_par, 
    s1d13xxx_getcolreg, 
    s1d13xxx_setcolreg, 
    s1d13xxx_pan_display,
    s1d13xxx_blank,
    s1d13xxx_set_disp
    }; 

static FB_INFO_S1D13xxx fb_info;  
static struct display disp;  
static char __initdata default_fontname[40] = { 0 }; 

//----------------------------------------------------------------------------- 
// 
// This function should detect the current video mode settings and store  
// it as the default video mode 
//  
//----------------------------------------------------------------------------- 
static void s1d13xxx_detect(void) 
    { 
    } 

//----------------------------------------------------------------------------- 
// 
// This function should fill in the 'fix' structure based on the values  
// in the `par' structure.  
//  
//----------------------------------------------------------------------------- 
static int s1d13xxx_encode_fix(struct fb_fix_screeninfo *fix, const void *par, 
                struct fb_info_gen *info) 
    { 
    memset(fix, 0, sizeof(struct fb_fix_screeninfo));
    strcpy(fix->id, fb_info.gen.info.modename);

    fix->type = FB_TYPE_PACKED_PIXELS;  /* see FB_TYPE_* in fb.h    */       
    fix->type_aux = 0;                  /* Interleave for interleaved Planes */

    /* set fix->line_length to the length of the line in bytes */
    fix->line_length = S1D_DISPLAY_SCANLINE_BYTES;      

#ifdef FBCON_HAS_MFB
    fix->visual = FB_VISUAL_MONO10;
#endif

#ifdef FBCON_HAS_CFB2 
    fix->visual = FB_VISUAL_PSEUDOCOLOR;
#endif

#ifdef FBCON_HAS_CFB4 
    fix->visual = FB_VISUAL_PSEUDOCOLOR;
#endif

#ifdef FBCON_HAS_CFB8
    fix->visual = FB_VISUAL_PSEUDOCOLOR;
#endif

#ifdef FBCON_HAS_CFB16
    fix->visual = FB_VISUAL_TRUECOLOR;
#endif

#ifdef CONFIG_FBCON_EPSON_PCI 
    #if (defined (CONFIG_FBCON_EPSON_S1D13705) || (CONFIG_FBCON_EPSON_S1D13704))

	/* Start and length of frame buffer mem */
	fix->smem_start = fb_info.PhysAddr;
	fix->smem_len   = S1D_PHYSICAL_VMEM_SIZE;

        /* Start and length of Memory Mapped I/O */
        fix->mmio_len   = S1D_PHYSICAL_REG_SIZE;

        #ifdef CONFIG_FBCON_EPSON_S1D13705	    
            fix->mmio_start = (fb_info.PhysAddr+0x1FFE0);
        #endif

        #ifdef CONFIG_FBCON_EPSON_S1D13704	    
            fix->mmio_start = (fb_info.PhysAddr+0x0FFE0);
        #endif

    #else
        /* Start and length of Memory Mapped I/O */ 
        fix->mmio_start = fb_info.PhysAddr;  
        fix->mmio_len   = S1D_PHYSICAL_REG_SIZE;    

        /* Start and length of frame buffer mem */ 
        fix->smem_start = (fb_info.PhysAddr+0x200000);
        fix->smem_len   = S1D_PHYSICAL_VMEM_SIZE;
    #endif

#else 
    /* Start and length of Memory Mapped I/O */ 
    fix->mmio_start = S1D_PHYSICAL_REG_ADDR;     
    fix->mmio_len   = S1D_PHYSICAL_REG_SIZE;    

    /* Start and length of frame buffer mem */ 
    fix->smem_start = S1D_PHYSICAL_VMEM_ADDR;    
    fix->smem_len   = S1D_PHYSICAL_VMEM_SIZE;   
#endif

    fix->xpanstep = fix->ypanstep = fix->ywrapstep = 0;
    fix->accel = FB_ACCEL_NONE;

    return 0;
    } 
 
//----------------------------------------------------------------------------- 
// 
//  Get the video params out of 'var'. If a value doesn't fit, round it up,  
//  if it's too big, return -EINVAL.  
//  
//  Suggestion: Round up in the following order: bits_per_pixel, xres,  
//  yres, xres_virtual, yres_virtual, xoffset, yoffset, grayscale,  
//  bitfields, horizontal timing, vertical timing.  
//  
//----------------------------------------------------------------------------- 
static int s1d13xxx_decode_var(const struct fb_var_screeninfo *var, void *fb_par, 
                struct fb_info_gen *info) 
    { 
    return 0; 
    } 

//----------------------------------------------------------------------------- 
//
// Fill the 'var' structure based on the values in 'par' and maybe other 
// values read out of the hardware. 
// 
//----------------------------------------------------------------------------- 
static int s1d13xxx_encode_var(struct fb_var_screeninfo *var, const void *fb_par,
                struct fb_info_gen *info)
    { 
    memset(var, 0, sizeof(struct fb_var_screeninfo));

    var->xres =  S1D_DISPLAY_WIDTH;     //visible resolution
    var->yres =  S1D_DISPLAY_HEIGHT;

    var->xres_virtual = var->xres;
    var->yres_virtual = var->yres;
    var->xoffset = var->yoffset = 0;
    var->bits_per_pixel = S1D_DISPLAY_BPP;
    var->grayscale = 0;
    var->nonstd = 0;                 /* != 0 Non standard pixel format */
    var->activate = FB_ACTIVATE_NOW; /* see FB_ACTIVATE_*              */
    var->height = -1;                /* height of picture in mm        */
    var->width  = -1;                /* width of picture in mm         */
    var->accel_flags = 0;            /* acceleration flags (hints      */
    var->pixclock = S1D_DISPLAY_PCLK;
    var->right_margin = 0;
    var->lower_margin = 0;
    var->hsync_len = 0;
    var->vsync_len = 0;
    var->left_margin = 0;
    var->upper_margin = 0;
    var->sync = 0;
    var->vmode = FB_VMODE_NONINTERLACED;

#if defined (FBCON_HAS_MFB) || defined (FBCON_HAS_CFB2) || \
    defined (FBCON_HAS_CFB4) || defined (FBCON_HAS_CFB8)
    var->red.offset = var->green.offset = var->blue.offset = 0;
    var->red.length = var->green.length = var->blue.length = S1D_DISPLAY_BPP;
#endif

#ifdef FBCON_HAS_CFB16  // RGB 565
    var->red.offset = 11;
    var->red.length = 5;
    var->green.offset = 5;
    var->green.length = 6;
    var->blue.offset = 0;
    var->blue.length = 5;
#endif

    var->red.msb_right = var->green.msb_right = var->blue.msb_right = 0;
    var->transp.offset = var->transp.length = var->transp.msb_right = 0;

    return 0; 
    } 
 
//----------------------------------------------------------------------------- 
//
// Set the 'par' according to hardware
//
//----------------------------------------------------------------------------- 
static void s1d13xxx_get_par(void *fb_par, struct fb_info_gen *info) 
    { 
    } 
 
//----------------------------------------------------------------------------- 
//
// Set the hardware according to 'par'. 
//
//----------------------------------------------------------------------------- 
static void s1d13xxx_set_par(const void *fb_par, struct fb_info_gen *info)
    { 
    } 
 
//----------------------------------------------------------------------------- 
// 
// Read a single color register and split it into colors/transparent.  
// The return values must have a 16 bit magnitude.  
// Return != 0 for invalid regno.  
// 
//----------------------------------------------------------------------------- 
static int s1d13xxx_getcolreg(unsigned regno, unsigned *red, unsigned *green, 
                unsigned *blue, unsigned *transp, struct fb_info *info) 
    { 
    u32 r,g,b;

    if (regno >= S1D_PALETTE_SIZE) 
        return 1; 

    S1D_READ_PALETTE(fb_info.RegAddr,regno,r,g,b);  

    *red    = (r << 8) | r; 
    *green  = (g << 8) | g; 
    *blue   = (b << 8) | b; 
    *transp = 0; 

//    printk("S1D13XXX: (getcolreg) i:%d r=%x g=%x b=%x\n", regno,*red,*green,*blue);
    return 0; 
    } 
 
//---------------------------------------------------------------------------- 
// 
// Set a single color register. The values supplied have a 16 bit  
// magnitude.  
// Return != 0 for invalid regno.  
//
// We get called even if we specified that we don't have a programmable palette
// or in direct/true color modes!
//---------------------------------------------------------------------------- 
static int s1d13xxx_setcolreg(unsigned regno, unsigned red, unsigned green,
                unsigned blue, unsigned transp, struct fb_info *info) 
    { 
//    printk("S1D13XXX: (setcolreg) i:%d r=%x g=%x b=%x\n", regno,red,green,blue);

    if (regno >= S1D_PALETTE_SIZE) 
        return 1; 
    
    S1D_WRITE_PALETTE(fb_info.RegAddr,regno,red>>8,green>>8,blue>>8); 

#if defined(FBCON_HAS_CFB16) 
    // Make the first 16 colors of the palette available to fbcon 

    if (regno < 16) 
        {
        fb_info.cfb16[regno] = 
            (red & 0xf800)|((green & 0xfc00) >> 5)|((blue & 0xf800) >> 11); 
        }
#endif
    return 0; 
    } 
 
//-----------------------------------------------------------------------------
// 
// Pan (or wrap, depending on the `vmode' field) the display using the 
// `xoffset' and `yoffset' fields of the `var' structure. 
// If the values don't fit, return -EINVAL. 
// 
//-----------------------------------------------------------------------------
static int s1d13xxx_pan_display(const struct fb_var_screeninfo *var, 
                struct fb_info_gen *info) 
    { 
    return 0; 
    } 
 
//-----------------------------------------------------------------------------
//     
// Blank the screen if blank_mode != 0, else unblank. If blank == NULL  
// then the caller blanks by setting the CLUT (Color Look Up Table) to all  
// black. Return 0 if blanking succeeded, != 0 if un-/blanking failed due  
// to e.g. a video mode which doesn't support it. Implements VESA suspend  
// and powerdown modes on hardware that supports disabling hsync/vsync:  
//     
// 0 = unblank 
// 1 = blank 
// 2 = suspend vsync 
// 3 = suspend hsync 
// 4 = off 
//
//----------------------------------------------------------------------------- 
static int asleep=0;
static int blanked=0;
static u32 savedlightstate=0x3E;
static int s1d13xxx_blank(int blank_mode, struct fb_info_gen *info)
    {
    u32 val;
    if (blank_mode) {
		while ( ( ( ((S1D_VALUE *)fb_info.RegAddr)[0x14/sizeof(S1D_VALUE)] ) & 0x80 ) != 0x80 ) ; /*wait for a blanking period to start */
		while ( ( ( ((S1D_VALUE *)fb_info.RegAddr)[0x14/sizeof(S1D_VALUE)] ) & 0x80 ) == 0x80 ) ; /*wait for blanking period to end */
		while ( ( ( ((S1D_VALUE *)fb_info.RegAddr)[0x14/sizeof(S1D_VALUE)] ) & 0x80 ) != 0x80 ) ; /*wait for another blanking period to start */
		((S1D_VALUE *)fb_info.RegAddr)[0x70/sizeof(S1D_VALUE)]=(SYS_IS_TS2?BACKLIGHT_OFF_TS2:BACKLIGHT_OFF_TS1); /*backlight off*/
		((S1D_VALUE *)fb_info.RegAddr)[0x10/sizeof(S1D_VALUE)]|=0x00800000;
		mdelay(100);
		((S1D_VALUE *)fb_info.RegAddr)[0x68/sizeof(S1D_VALUE)]=0x48F; /*MOD off*/
		((S1D_VALUE *)fb_info.RegAddr)[0x68/sizeof(S1D_VALUE)]=0x481; /* triple supply off*/
		blanked=1;

    } else {
		((S1D_VALUE *)fb_info.RegAddr)[0x68/sizeof(S1D_VALUE)]=0x48F; /*triple supply on*/
		mdelay(50); /*wait for supply to come up*/
		((S1D_VALUE *)fb_info.RegAddr)[0x68/sizeof(S1D_VALUE)]=0x49F; /*MOD on*/
                while ( ( ( ((S1D_VALUE *)fb_info.RegAddr)[0x14/sizeof(S1D_VALUE)] ) & 0x80 ) != 0x80 ) ; /*wait for a blanking period to start */
                while ( ( ( ((S1D_VALUE *)fb_info.RegAddr)[0x14/sizeof(S1D_VALUE)] ) & 0x80 ) == 0x80 ) ; /*wait for blanking period to end */
                while ( ( ( ((S1D_VALUE *)fb_info.RegAddr)[0x14/sizeof(S1D_VALUE)] ) & 0x80 ) != 0x80 ) ; /*wait for another blanking period to start */
                ((S1D_VALUE *)fb_info.RegAddr)[0x10/sizeof(S1D_VALUE)]&=(~0x00800000);
		((S1D_VALUE *)fb_info.RegAddr)[0x70/sizeof(S1D_VALUE)]=savedlightstate;
                blanked=0;

    }
    return 0; 
    } 
 
//----------------------------------------------------------------------------- 
//
// Fill in a pointer with the virtual address of the mapped frame buffer.  
// Fill in a pointer to appropriate low level text console operations (and  
// optionally a pointer to help data) for the video mode `par' of your  
// video hardware. These can be generic software routines, or hardware  
// accelerated routines specifically tailored for your hardware.  
// If you don't have any appropriate operations, you must fill in a  
// pointer to dummy operations, and there will be no text output.  
//
//----------------------------------------------------------------------------- 
static void s1d13xxx_set_disp(const void *par, struct display *disp,
                struct fb_info_gen *info)
    { 
    disp->screen_base = fb_info.VmemAddr;

#ifdef FBCON_HAS_MFB
    disp->dispsw = &fbcon_mfb;
#endif

#ifdef FBCON_HAS_CFB2
    disp->dispsw = &fbcon_cfb2;
#endif

#ifdef FBCON_HAS_CFB4
    disp->dispsw = &fbcon_cfb4;
#endif

#ifdef FBCON_HAS_CFB8
    disp->dispsw = &fbcon_cfb8;
#endif

#ifdef FBCON_HAS_CFB16
    disp->dispsw = &fbcon_cfb16;
    disp->dispsw_data = fb_info.cfb16;  /* console palette */
#endif

    disp->scrollmode = SCROLL_YREDRAW;
    } 
 
//----------------------------------------------------------------------------- 
//
// Detect our PCI bridge adapter card, get the BAR[0]. Card is assumed to be
// enabled. 
//
//----------------------------------------------------------------------------- 
#ifdef CONFIG_FBCON_EPSON_PCI 
static int __init
s1d13xxx_IsOurID(unsigned vID, unsigned dID)
    { 
    if (vID == 0x10F4 && dID == 0x1300) 
        return 1; 

    if (vID == 0x14EB) 
        { 
        if (dID >= 0x0000 && dID < 0x002A) 
            return 1; 
        if (dID > 0x002A && dID <= 0x002F) 
            return 1; 
        } 
    return 0; 
    } 

unsigned long __init
s1d13xxx_get_physical_address(void) 
    { 
    struct pci_dev *pdev; 
 
    pdev = NULL;
    pci_for_each_dev(pdev) 
        {
        if (s1d13xxx_IsOurID(pdev->vendor,pdev->device)) 
            return (pci_resource_start(pdev, 0) & PCI_BASE_ADDRESS_MEM_MASK); 
        }
    return 0;
    }
#endif
 
//----------------------------------------------------------------------------- 
//
// Initialize the chip and the frame buffer driver. 
//
//----------------------------------------------------------------------------- 
int __init
s1d13xxxfb_init(char *dummy)
    {
    int i;
    int preinit=0;
    S1D_INDEX s1dReg;
    S1D_VALUE s1dValue;

#ifdef CONFIG_FBCON_EPSON_PCI

    unsigned long phAddr = s1d13xxx_get_physical_address();
    printk("S1D13XXX: PCI Phys address:%lx\n", phAddr);

    #ifdef CONFIG_FBCON_EPSON_S1D13705
       fb_info.VmemAddr = (unsigned char*) ioremap(phAddr,0x1FFE0+S1D_PHYSICAL_REG_SIZE);
       fb_info.RegAddr  = fb_info.VmemAddr + 0x1FFE0;
    #else
       #ifdef CONFIG_FBCON_EPSON_S1D13704
          fb_info.VmemAddr = (unsigned char*) ioremap(phAddr,0xDFFE0+S1D_PHYSICAL_REG_SIZE);
          fb_info.RegAddr  = fb_info.VmemAddr + 0xDFFE0;
       #else
          fb_info.RegAddr  = (unsigned char*) ioremap(phAddr,S1D_PHYSICAL_REG_SIZE); 
          fb_info.VmemAddr = (unsigned char*) ioremap_nocache(phAddr+0x200000,S1D_PHYSICAL_VMEM_SIZE);
       #endif
    #endif

    fb_info.PhysAddr = phAddr;

#else
    fb_info.VmemAddr = (unsigned char*) ioremap_nocache(S1D_PHYSICAL_VMEM_ADDR,S1D_PHYSICAL_VMEM_SIZE); 
    fb_info.RegAddr  = (unsigned char*) ioremap(S1D_PHYSICAL_REG_ADDR,S1D_PHYSICAL_REG_SIZE); 
#endif

    if (!fb_info.VmemAddr || !fb_info.RegAddr)  
        { 
        printk("S1D13xxx_init: ioremap() returned NULL\n"); 
        return -EINVAL;
        }
    if (((S1D_VALUE *)fb_info.RegAddr)[0x70/sizeof(S1D_VALUE)]==0x0E) preinit=1;
    if (!preinit) for (i = 0; i < (S1D_PHYSICAL_VMEM_SIZE/sizeof(unsigned int)) ; i++) {
        ((unsigned int *)fb_info.VmemAddr)[i]=0;
    }
    if (SYS_IS_TS2) savedlightstate=BACKLIGHT_ON_TS2;
    if (!preinit) for (i = 0; i < sizeof(aS1DRegs)/sizeof(aS1DRegs[0]); i++)
        {
        s1dReg = aS1DRegs[i].Index; 
        s1dValue = aS1DRegs[i].Value; 
	if ((SYS_IS_TS2)&&(s1dReg == 0x70)) s1dValue=BACKLIGHT_ON_TS2;
        if (s1dReg == S1D_REGDELAYOFF || s1dReg == S1D_REGDELAYON)
            mdelay((int)s1dValue);
        else
            {
            ((S1D_VALUE*)fb_info.RegAddr)[s1dReg/sizeof(S1D_VALUE)] = s1dValue; 
//            printk("S1D13xxx: reg:%X val=%X\n",s1dReg,s1dValue);
            }
        }
         
	if (((S1D_VALUE *)fb_info.RegAddr)[0x08/sizeof(S1D_VALUE)]==0x03) {
//		printk("Looks like a TS-2C/MP unit, switching MCLK to 30MHz\n");
		((S1D_VALUE *)fb_info.RegAddr)[0x04/sizeof(S1D_VALUE)]=0x10;
	}

    strcpy(fb_info.gen.info.modename, "s1d13xxx"); 
    fb_info.gen.info.changevar = NULL; 
    fb_info.gen.info.node = -1; 
    fb_info.gen.info.fbops = &s1d13xxxfb_ops; 
    fb_info.gen.info.disp = &disp; 

    fb_info.gen.info.switch_con = &fbgen_switch;
    fb_info.gen.info.updatevar = &fbgen_update_var;
    fb_info.gen.info.blank = &fbgen_blank;
 
    strcpy(fb_info.gen.info.fontname, default_fontname);
    fb_info.gen.parsize = 0;
    fb_info.gen.info.flags = FBINFO_FLAG_DEFAULT; 
    fb_info.gen.fbhw = &s1d13xxx_hwswitch; 
    fb_info.gen.fbhw->detect(); 

    fbgen_get_var(&disp.var, -1, &fb_info.gen.info); 
    disp.var.activate = FB_ACTIVATE_NOW;
    fbgen_do_set_var(&disp.var, 1, &fb_info.gen); 
    fbgen_set_disp(-1, &fb_info.gen); 
    fbgen_install_cmap(0, &fb_info.gen); 
 
    if (register_framebuffer(&fb_info.gen.info) < 0) 
        return -EINVAL;

    printk("S1D13xxx: fb%d: %s frame buffer device\n", GET_FB_IDX(fb_info.gen.info.node), 
        fb_info.gen.info.modename); 

    printk("S1D13xxx: Display %d x %d %dBpp\n", 
        S1D_DISPLAY_WIDTH,S1D_DISPLAY_HEIGHT,S1D_DISPLAY_BPP); 
#ifdef CONFIG_SH_SONOS_HH
    rincon_pm_register(&epson_pmdevice);
    printk("Registered Epson frame buffer power management device\n");
#endif
    return 0;
    } 
 
//----------------------------------------------------------------------------- 
//
// Parse user speficied options (`video=s1d13xxxfb:')  
//
//----------------------------------------------------------------------------- 
int __init
s1d13xxxfb_setup(char *options, int *ints) 
    { 
    return 0;
    }
 
/* ------------------------------------------------------------------------- */ 

#if defined(CONFIG_SH_SONOS_HH)

#define GC_BACKLIGHT_PWM		0x74

static int s1d13xxxfb_ioctl(struct inode *inode, struct file *file,
              u_int cmd, u_long arg, int con, struct fb_info *info)
{
	u32 val;

    switch(cmd)
    {
    case S1D13XXXFB_SET_PWM:
        if (copy_from_user(&val, (void *) arg, sizeof(val)))
            return( -EFAULT );
		
		if(!SYS_IS_TS2) {
			if (val>240) val=240;
			if (val==0) {
				((S1D_VALUE *)fb_info.RegAddr)[0x70/sizeof(S1D_VALUE)]=0x3E;
				savedlightstate=0x3E;
				return 0;
			} else {
				((S1D_VALUE *)fb_info.RegAddr)[0x70/sizeof(S1D_VALUE)]=0x37;
				savedlightstate=0x37;
			}
			val = 255-val ;
		} else {
			if (val>=255) {
				((S1D_VALUE *)fb_info.RegAddr)[0x70/sizeof(S1D_VALUE)]=BACKLIGHT_ON_FULL_TS2;
				savedlightstate=BACKLIGHT_ON_FULL_TS2;
				return 0;
			} else {
				((S1D_VALUE *)fb_info.RegAddr)[0x70/sizeof(S1D_VALUE)]=BACKLIGHT_ON_TS2;
				savedlightstate=BACKLIGHT_ON_TS2;
			}
		}
		((S1D_VALUE*)fb_info.RegAddr)[GC_BACKLIGHT_PWM/sizeof(S1D_VALUE)] = val;
        return( 0 );

	case S1D13XXXFB_GET_PWM:
		val = ((S1D_VALUE*)fb_info.RegAddr)[GC_BACKLIGHT_PWM/sizeof(S1D_VALUE)];

		if( !SYS_IS_TS2 )
			val=255-val;

		if ((SYS_IS_TS2)&&(((S1D_VALUE *)fb_info.RegAddr)[0x70]==BACKLIGHT_ON_FULL_TS2)) val=255;
		if( copy_to_user( (void *)arg, &val, sizeof(val) ))
			return( -EFAULT );
		return( 0 );
    }
	return( -EINVAL );
}

static void sleep(struct pmdevice *pmd)
{
	u32 val;
	int u;
	if (asleep) return;
#if 0
	savedlightstate=((S1D_VALUE *)fb_info.RegAddr)[0x70/sizeof(S1D_VALUE)];
#endif
	((S1D_VALUE *)fb_info.RegAddr)[0x70/sizeof(S1D_VALUE)]=(SYS_IS_TS2?BACKLIGHT_OFF_TS2:BACKLIGHT_OFF_TS1); /*backlight off*/
	if (!blanked) {
		s1d13xxx_blank(1,0);
		blanked=0;
		mdelay(100);
	}
#if 0
	while ( ( ( ((S1D_VALUE *)fb_info.RegAddr)[0x14/sizeof(S1D_VALUE)] ) & 0x80 ) != 0x80 ) ; /*wait for a blanking period to start */
	while ( ( ( ((S1D_VALUE *)fb_info.RegAddr)[0x14/sizeof(S1D_VALUE)] ) & 0x80 ) == 0x80 ) ; /*wait for blanking period to end */
	while ( ( ( ((S1D_VALUE *)fb_info.RegAddr)[0x14/sizeof(S1D_VALUE)] ) & 0x80 ) != 0x80 ) ; /*wait for another blanking period to start */
#endif
#if 0
	((S1D_VALUE *)fb_info.RegAddr)[0x10/sizeof(S1D_VALUE)]|=0x00800000; /*blank*/
	mdelay(100);
#endif
#if 0
	((S1D_VALUE *)fb_info.RegAddr)[0x68/sizeof(S1D_VALUE)]=0x48F;
	mdelay(100);
#endif
	((S1D_VALUE *)fb_info.RegAddr)[0x14/sizeof(S1D_VALUE)]=0x10; /*turn on power-save mode*/
	while (( ( ((S1D_VALUE *)fb_info.RegAddr)[0x14/sizeof(S1D_VALUE)]) & 0x40)!=0x40) ; /*wait for memory controller to stop */
	((S1D_VALUE *)fb_info.RegAddr)[0x68/sizeof(S1D_VALUE)]=0x480; /*power off*/
	asleep=1;
}

static void wake(struct pmdevice *pmd)
{
	u32 val;
	if (asleep!=1) return;
	((S1D_VALUE *)fb_info.RegAddr)[0x68/sizeof(S1D_VALUE)]=0x481; /*3.3v on*/
	mdelay(1);
	((S1D_VALUE *)fb_info.RegAddr)[0x14/sizeof(S1D_VALUE)]=0; /*turn off power-save mode*/
	if (!blanked) {
		s1d13xxx_blank(0,0);
	}
#if 0
	((S1D_VALUE *)fb_info.RegAddr)[0x68/sizeof(S1D_VALUE)]=0x481;
	((S1D_VALUE *)fb_info.RegAddr)[0x68/sizeof(S1D_VALUE)]=0x483;
	((S1D_VALUE *)fb_info.RegAddr)[0x68/sizeof(S1D_VALUE)]=0x487;
#endif
#if 0
	((S1D_VALUE *)fb_info.RegAddr)[0x68/sizeof(S1D_VALUE)]=0x48F;
	mdelay(50); /*wait for power supplies to come up*/
	while ( ( ( ((S1D_VALUE *)fb_info.RegAddr)[0x14/sizeof(S1D_VALUE)] ) & 0x80 ) != 0x80 ) ; /*wait for a blanking period to start */
	while ( ( ( ((S1D_VALUE *)fb_info.RegAddr)[0x14/sizeof(S1D_VALUE)] ) & 0x80 ) == 0x80 ) ; /*wait for blanking period to end */
	while ( ( ( ((S1D_VALUE *)fb_info.RegAddr)[0x14/sizeof(S1D_VALUE)] ) & 0x80 ) != 0x80 ) ; /*wait for another blanking period to start */
	((S1D_VALUE *)fb_info.RegAddr)[0x68/sizeof(S1D_VALUE)]=0x49F;
#endif
#if 0
	mdelay(1);
	((S1D_VALUE *)fb_info.RegAddr)[0x10/sizeof(S1D_VALUE)]&=(~0x00800000);
#endif
	((S1D_VALUE *)fb_info.RegAddr)[0x70/sizeof(S1D_VALUE)]=savedlightstate;
	asleep=0;
}


#endif

/* 
 *  Modularization 
 */ 
#ifdef MODULE 
int init_module(void) 
    { 
    s1d13xxxfb_init(); 
    return 0; 
    } 
 
void cleanup_module(void) 
    { 
    unregister_framebuffer(&fb_info.gen.info); 
    } 
#endif 
